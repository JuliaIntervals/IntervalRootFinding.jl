var documenterSearchIndex = {"docs":
[{"location":"roots/#roots-interface-1","page":"roots interface","title":"roots interface","text":"","category":"section"},{"location":"roots/#Methods-1","page":"roots interface","title":"Methods","text":"","category":"section"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"Three root-finding methods currently available through the roots interface are the following:","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"Newton (default);\nKrawczyk;\nBisection","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"Both the Newton and Krawczyk methods can determine if a root is unique in an interval, at the cost of requiring that the function is differentiable. The bisection method has no such requirement, but can never guarantee the existence or uniqueness of a root.","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"The method used is given as the third (optional) argument of the roots function:","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"julia> roots(log, -2..2, Newton)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999996, 1.00001], :unique)\n\njulia> roots(log, -2..2, Krawczyk)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999984, 1.00002], :unique)\n\njulia> roots(log, -2..2, Bisection)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999454, 1.00039], :unknown)","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"Note that as shown in the example, the log function does not complain about being given an interval going outside of its domain. While this may be surprising, this is the expected behavior and no root will ever be found outside the domain of a function.","category":"page"},{"location":"roots/#Explicit-derivatives-1","page":"roots interface","title":"Explicit derivatives","text":"","category":"section"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"Newton and Krawczyk methods require the function to be differentiable, but the derivative is usually computed automatically using forward-mode automatic differentiation, provided by the ForwardDiff.jl package. It is however possible to provide the derivative explicitly for these methods as the second argument of the roots function:","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"julia> roots(log, x -> 1/x, -2..2, Newton)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999996, 1.00001], :unique)\n\njulia> roots(log, x -> 1/x, -2..2, Krawczyk)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999984, 1.00002], :unique)","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"When providing the derivative explicitly, the computation is expected to be slightly faster, but the precision of the result is unlikely to be affected.","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"julia> using BenchmarkTools\n\njulia> @btime roots(log, x -> 1/x, -2..2, Newton)\n  38.600 Œºs (371 allocations: 27.01 KiB)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999996, 1.00001], :unique)\n\njulia> @btime roots(log, -2..2, Newton)\n  51.799 Œºs (373 allocations: 27.20 KiB)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999996, 1.00001], :unique)","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"This may be useful in some special cases where ForwardDiff.jl is unable to compute the derivative of a function. Examples are complex functions and functions whose interval extension must be manually defined (e.g. special functions like zeta).","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"In dimension greater than one, the function of interest must return a SVector, a type provided by the StaticArrays package, but otherwise works in the same way as in the 1D case.","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"julia> function f( (x, y) )\n           return SVector(sin(x), cos(y))\n       end\nf (generic function with 1 method)\n\njulia> roots(f, IntervalBox(-3..3, 2))\n2-element Array{Root{IntervalBox{2,Float64}},1}:\n Root([-1.13556e-19, 2.3664e-20] √ó [1.57079, 1.5708], :unique)\n Root([-7.92188e-19, 3.20973e-19] √ó [-1.5708, -1.57079], :unique)","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"When providing the derivative for a multi-dimensional function, this must be given as a function returning the Jacobi matrix of the function as an SMatrix:","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"julia> function df( (x, y) )\n           return SMatrix{2, 2}(cos(x), 0, 0, -sin(y))\n       end\ndf (generic function with 1 method)\n\njulia> roots(f, df, IntervalBox(-3..3, 2), Newton)\n2-element Array{Root{IntervalBox{2,Float64}},1}:\n Root([-2.35877e-07, 8.22858e-07] √ó [1.57079, 1.5708], :unique)\n Root([-7.19393e-07, 1.55473e-06] √ó [-1.5708, -1.57079], :unique)","category":"page"},{"location":"roots/#Tolerance-1","page":"roots interface","title":"Tolerance","text":"","category":"section"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"An absolute tolerance for the search may be specified as the last argument of the roots function, the default being 1e-15. Currently a method must first be provided in order to be able to choose the tolerance.","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"julia> g(x) = sin(exp(x))\ng (generic function with 1 method)\n\njulia> roots(g, 0..2, Newton)\n2-element Array{Root{Interval{Float64}},1}:\n Root([1.83787, 1.83788], :unique)\n Root([1.14472, 1.14473], :unique)\n\njulia> roots(g, 0..2, Newton, 1e-2)\n2-element Array{Root{Interval{Float64}},1}:\n Root([1.83745, 1.83974], :unique)\n Root([1.14471, 1.14475], :unique)","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"A lower tolerance may greatly reduce the computation time, at the cost of an increased number of returned roots having :unknown status:","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"julia> h(x) = cos(x) * sin(1 / x)\nh (generic function with 1 method)\n\njulia> @btime roots(h, 0.05..1, Newton)\n  1.316 ms (9676 allocations: 202.21 KiB)\n6-element Array{Root{Interval{Float64}},1}:\n Root([0.106103, 0.106104], :unique)\n Root([0.318309, 0.31831], :unique)\n Root([0.0795774, 0.0795775], :unique)\n Root([0.0636619, 0.063662], :unique)\n Root([0.0530516, 0.0530517], :unique)\n Root([0.159154, 0.159155], :unique)             \n\njulia> @btime roots(h, 0.05..1, Newton, 1e-2)\n   475.500 Œºs (4171 allocations: 94.00 KiB)\n 6-element Array{Root{Interval{Float64}},1}:\n  Root([0.317179, 0.319299], :unique)\n  Root([0.157209, 0.165989], :unknown)\n  Root([0.104739, 0.107542], :unknown)\n  Root([0.0515382, 0.0531049], :unique)\n  Root([0.0785458, 0.0797755], :unknown)\n  Root([0.0570253, 0.0641614], :unknown)\n\njulia> @btime roots(h, 0.05..1, Newton, 1e-1)\n  151.101 Œºs (1382 allocations: 32.86 KiB)\n3-element Array{Root{Interval{Float64}},1}:\n Root([0.107541, 0.165989], :unknown)\n Root([0.283803, 0.3555], :unknown)\n Root([0.0499999, 0.107542], :unknown)     ","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"The last example shows a case where the tolerance was too large to be able to isolate the roots in distinct regions.","category":"page"},{"location":"roots/#","page":"roots interface","title":"roots interface","text":"warning: Warning\nFor a root x of some function, if the absolute tolerance is smaller than eps(x) i.e. if tol + x == x, roots may never be able to converge to the required tolerance and the function may get stuck in an infinite loop.","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Main-interface-1","page":"API","title":"Main interface","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [IntervalRootFinding]\nPages   = [\"roots.jl\"]","category":"page"},{"location":"api/#IntervalRootFinding.BreadthFirstSearch","page":"API","title":"IntervalRootFinding.BreadthFirstSearch","text":"BreadthFirstSearch <: BreadthFirstBBSearch\n\nType implementing  the BreadthFirstBBSearch interface for interval roots finding.\n\nFields:\n\ninitial: region (as a Root object) in which roots are searched.\ncontractor: contractor to use (Bisection, Newton or Krawczyk)\ntol: tolerance of the search\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.DepthFirstSearch","page":"API","title":"IntervalRootFinding.DepthFirstSearch","text":"DepthFirstSearch <: DepthFirstBBSearch\n\nType implementing the DepthFirstBBSearch interface for interval roots finding.\n\nFields:\n\ninitial: region (as a Root object) in which roots are searched.\ncontractor: contractor to use (Bisection, Newton or Krawczyk)\ntol: tolerance of the search\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.branch_and_prune-Tuple{Root,Any,Any,Any}","page":"API","title":"IntervalRootFinding.branch_and_prune","text":"branch_and_prune(X, contractor, strategy, tol)\n\nGeneric branch and prune routine for finding isolated roots using the given contractor to determine the status of a given box X.\n\nSee the documentation of the roots function for explanation of the other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Polynomials.roots-Union{Tuple{S}, Tuple{C}, Tuple{Function,Any}, Tuple{Function,Any,Type{C}}, Tuple{Function,Any,Type{C},Type{S}}, Tuple{Function,Any,Type{C},Type{S},Float64}} where S<:BBSearch where C<:Contractor","page":"API","title":"Polynomials.roots","text":"roots(f, X, contractor=Newton, strategy=BreadthFirstSearch, tol=1e-15)\nroots(f, deriv, X, contractor=Newton, strategy=BreadthFirstSearch, tol=1e-15)\nroots(f, X, contractor, tol)\nroots(f, deriv, X, contractor, tol)\n\nUses a generic branch and prune routine to find in principle all isolated roots of a function f:R^n ‚Üí R^n in a region X, if the number of roots is finite.\n\nInputs:\n\nf: function whose roots will be found\nX: Interval or IntervalBox in which roots are searched\ncontractor: function that, when applied to the function f, determines the status of a given box X. It returns the new box and a symbol indicating the status. Current possible values are Bisection, Newton and Krawczyk\nderiv: explicit derivative of f for Newton and Krawczyk\nstrategy: SearchStrategy determining the order in which regions are processed.\ntol: Absolute tolerance. If a region has a diameter smaller than tol, it is returned with status :unknown.\n\n\n\n\n\n","category":"method"},{"location":"api/#Root-object-1","page":"API","title":"Root object","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [IntervalRootFinding]\nPages   = [\"root_object.jl\"]","category":"page"},{"location":"api/#IntervalRootFinding.Root","page":"API","title":"IntervalRootFinding.Root","text":"Root\n\nObject representing a possible root inside a given region. The field status is either :unknown or :unique. If status is :unique then we know that there is a unique root of the function in question inside the given region.\n\nInternally the status may also be :empty for region guaranteed to contain no root, however such Roots are discarded by default and thus never returned by the roots function.\n\nFields\n\ninterval: a region (either Interval of IntervalBox) searched for     roots.\nstatus: the status of the region, valid values are :empty, unkown and     :unique.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.isunique-Union{Tuple{Root{T}}, Tuple{T}} where T","page":"API","title":"IntervalRootFinding.isunique","text":"isunique(rt)\n\nReturn whether a Root is unique.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.root_status-Tuple{Root}","page":"API","title":"IntervalRootFinding.root_status","text":"root_status(rt)\n\nReturn the status of a Root.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.root_region-Tuple{Root}","page":"API","title":"IntervalRootFinding.root_region","text":"root_region(rt)\n\nReturn the region associated to a Root.\n\n\n\n\n\n","category":"method"},{"location":"api/#Contractors-1","page":"API","title":"Contractors","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [IntervalRootFinding]\nPages   = [\"contractors.jl\"]","category":"page"},{"location":"api/#IntervalRootFinding.Bisection","page":"API","title":"IntervalRootFinding.Bisection","text":"Bisection{F} <: Contractor{F}\n\nContractor type for the bisection method.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.Contractor","page":"API","title":"IntervalRootFinding.Contractor","text":"Contractor{F}\n\nAbstract type for contractors.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.Krawczyk","page":"API","title":"IntervalRootFinding.Krawczyk","text":"Krawczyk{F, FP} <: Contractor{F}\n\nContractor type for the Krawczyk method.\n\nFields\n\nf::F: function whose roots are searched\nf::FP: derivative or jacobian of f\n\n\n\n(C::Krawczyk)(X, tol, Œ±=where_bisect)\n\nContract an interval X using Krawczyk operator and return the contracted interval together with its status.\n\nInputs\n\nR: Root object containing the interval to contract.\ntol: Precision to which unique solutions are refined.\nŒ±: Point of bisection of intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.Newton","page":"API","title":"IntervalRootFinding.Newton","text":"Newton{F, FP} <: Contractor{F}\n\nContractor type for the Newton method.\n\nFields\n\nf::F: function whose roots are searched\nf::FP: derivative or jacobian of f\n\n\n\n(C::Newton)(X, tol, Œ±=where_bisect)\n\nContract an interval X using Newton operator and return the contracted interval together with its status.\n\nInputs\n\nR: Root object containing the interval to contract.\ntol: Precision to which unique solutions are refined.\nŒ±: Point of bisection of intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.determine_region_status-Tuple{Any,Any,Any}","page":"API","title":"IntervalRootFinding.determine_region_status","text":"determine_region_status(contract, f, R)\n\nContraction operation for contractors using the first derivative of the function.\n\nCurrently Newton and Krawczyk contractors use this.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.refine-Tuple{Any,Root,Any}","page":"API","title":"IntervalRootFinding.refine","text":"refine(op, X::Tuple{Symbol, Region}, tol)\n\nWrap the refine method to leave unchanged intervals that are not guaranteed to contain an unique solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.refine-Tuple{Any,Union{Interval{T}, IntervalBox{T,T1} where T1} where T,Any}","page":"API","title":"IntervalRootFinding.refine","text":"refine(op, X::Region, tol)\n\nGeneric refine operation for Krawczyk and Newton. This function assumes that it is already known that X contains a unique root.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.safe_isempty-Tuple{Any}","page":"API","title":"IntervalRootFinding.safe_isempty","text":"safe_isempty(X)\n\nSimilar to isempty function for IntervalBox, but also works for SVector of Interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.ùí¶-Union{Tuple{T}, Tuple{Any,Any,IntervalBox{T,T1} where T1,Any}} where T","page":"API","title":"IntervalRootFinding.ùí¶","text":"ùí¶(f, jacobian, X, Œ±)\n\nMulti-variable Krawczyk operator.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.ùí¶-Union{Tuple{T}, Tuple{Any,Any,Interval{T},Any}} where T","page":"API","title":"IntervalRootFinding.ùí¶","text":"ùí¶(f, f‚Ä≤, X, Œ±)\n\nSingle-variable Krawczyk operator.\n\nThe symbol for the operator is accessed with \\scrK<tab>.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.ùí©-Tuple{Function,Function,IntervalBox,Any}","page":"API","title":"IntervalRootFinding.ùí©","text":"ùí©(f, jacobian, X, Œ±)\n\nMulti-variable Newton operator.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.ùí©-Union{Tuple{T}, Tuple{Any,Any,Interval{T},Any}} where T","page":"API","title":"IntervalRootFinding.ùí©","text":"ùí©(f, f‚Ä≤, X, Œ±)\n\nSingle-variable Newton operator.\n\nThe symbol for the operator is accessed with \\scrN<tab>.\n\n\n\n\n\n","category":"method"},{"location":"api/#Branch-and-bound-search-interface-1","page":"API","title":"Branch-and-bound search interface","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [IntervalRootFinding]\nPages   = [\"branch_and_bound.jl\"]","category":"page"},{"location":"api/#IntervalRootFinding.BBSearch","page":"API","title":"IntervalRootFinding.BBSearch","text":"BBSearch{DATA}\n\nBranch and bound search interface in element of type DATA.\n\nThis interface provide an iterable that perform the search.\n\nThere is currently three types of search supported BreadFirstBBSearch, DepthFirstBBSearch and KeyBBSearch, each one processing the element of the tree in a different order. When subtyping one of these, the following methods must be implemented:\n\nroot_element(::BBSearch): return the element with which the search is started\nprocess(::BBSearch, elem::DATA): return a symbol representing the action     to perform with the element elem and an object of type DATA reprensenting     the state of the element after processing (may return elem unchanged).\nbisect(::BBSearch, elem::DATA): return two elements of type DATA build     by bisecting elem\n\nSubtyping BBSearch directly allows to have control over the order in which the elements are process. To do this the following methods must be implemented:\n\nroot_element(::BBSearch): return the first element to be processed. Use     to build the initial tree.\nget_leaf_id!(::BBSearch, wt::BBTree): return the id of the next leaf that     will be processed and remove it from the list of working leaves of wt.\ninsert_leaf!(::BBSearch, wt::BBTree, leaf::BBLeaf): insert a leaf in the     list of working leaves.\n\nValid symbols returned by the process function\n\n:store: the element is considered as final and is stored, it will not be     further processed\n:bisect: the element is bisected and each of the two resulting part will     be processed\n:discard: the element is discarded from the tree, allowing to free memory\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.data-Tuple{IntervalRootFinding.BBLeaf}","page":"API","title":"IntervalRootFinding.data","text":"data(leaf::BBLeaf)\n\nReturn the data stored in the leaf.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.data-Tuple{IntervalRootFinding.BBTree}","page":"API","title":"IntervalRootFinding.data","text":"data(wt::BBTree)\n\nReturn all the data stored in a BBTree as a list. The ordering of the elements is arbitrary.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.BBLeaf","page":"API","title":"IntervalRootFinding.BBLeaf","text":"BBLeaf{DATA} <: AbstractBBLeaf\n\nLeaf node of a BBTree that contains some data. Its status is either\n\n:working: the leaf will be further processed.\n:final: the leaf won't be touched anymore.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.BBNode","page":"API","title":"IntervalRootFinding.BBNode","text":"BBNode <: AbstractBBNode\n\nIntermediate node of a BBTree. Does not contain any data by itself, only redirect toward its children.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.BBTree","page":"API","title":"IntervalRootFinding.BBTree","text":"BBTree{DATA}\n\nTree storing the data used and produced by a branch and bound search in a structured way.\n\nNodes and leaves can be accessed using their index using the bracket syntax wt[node_id]. However this is slow, as nodes and leaves are stored separately.\n\nSupport the iterator interface. The element yielded by the iteration are tuples (node_id, lvl) where lvl is the depth of the node in the tree.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.KeyBBSearch","page":"API","title":"IntervalRootFinding.KeyBBSearch","text":"KeyBBSearch{DATA} <: BBSearch{DATA}\n\nInterface to a branch and bound search that use a key function to decide which element to process first. The search process first the element with the largest key as computed by keyfunc(ks::KeyBBSearch, elem).\n\nwarning: Warning\nUntested.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.discard_leaf!-Tuple{IntervalRootFinding.BBTree,Int64}","page":"API","title":"IntervalRootFinding.discard_leaf!","text":"discard_leaf!(wt::BBTree, id::Int)\n\nDelete the BBLeaf with index id and all its ancestors to which it is the last descendant.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.get_leaf_id!-Tuple{BreadthFirstBBSearch,IntervalRootFinding.BBTree}","page":"API","title":"IntervalRootFinding.get_leaf_id!","text":"get_leaf_id!(::BBSearch, wt::BBTree)\n\nReturn the id of the next leaf that will be processed and remove it from the list of working leaves.\n\nMust be define for custom searches that are direct subtype of BBSearch.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.insert_leaf!-Union{Tuple{DATA}, Tuple{Union{BreadthFirstBBSearch{DATA}, DepthFirstBBSearch{DATA}},BBTree{DATA},BBLeaf{DATA}}} where DATA","page":"API","title":"IntervalRootFinding.insert_leaf!","text":"insert_leaf!(::BBSearch, wt::BBTree, leaf::BBLeaf)\n\nInsert the id of a new leaf that has been produced by bisecting an older leaf into the list of working leaves.\n\nMust be define for custom searches that are direct subtype of BBSearch.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.nnodes-Tuple{IntervalRootFinding.BBTree}","page":"API","title":"IntervalRootFinding.nnodes","text":"nnodes(wt::BBTree)\n\nNumber of nodes (including leaves) in a BBTree.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.root_element-Tuple{BBSearch}","page":"API","title":"IntervalRootFinding.root_element","text":"root_element(search::BBSearch)\n\nReturn the initial element of the search. The BBTree will be build around it.\n\nCan be define for custom searches that are direct subtype of BBSearch, default behavior is to fetch the field initial of the search.\n\n\n\n\n\n","category":"method"},{"location":"api/#Others-1","page":"API","title":"Others","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [IntervalRootFinding]\nPages   = [\"complex.jl\", \"linear_eq.jl\", \"newton1d.jl\", \"quadratic.jl\", \"slopes.jl\"]","category":"page"},{"location":"api/#IntervalRootFinding.gauss_elimination_interval!-Tuple{AbstractArray,AbstractArray{T,2} where T,AbstractArray}","page":"API","title":"IntervalRootFinding.gauss_elimination_interval!","text":"Solves the system of linear equations using Gaussian Elimination. Preconditioning is used when the precondition keyword argument is true.\n\nREF: Luc Jaulin et al., Applied Interval Analysis, pg. 72\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.gauss_seidel_interval!-Tuple{AbstractArray,AbstractArray{T,2} where T,AbstractArray}","page":"API","title":"IntervalRootFinding.gauss_seidel_interval!","text":"Iteratively solves the system of interval linear equations and returns the solution set. Uses the Gauss-Seidel method (Hansen-Sengupta version) to solve the system. Keyword precondition to turn preconditioning off. Eldon Hansen and G. William Walster : Global Optimization Using Interval Analysis - Chapter 5 - Page 115\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.newton1d-Union{Tuple{T}, Tuple{Function,Function,Interval{T}}} where T","page":"API","title":"IntervalRootFinding.newton1d","text":"newton1d performs the interval Newton method on the given function f with its derivative f‚Ä≤ and initial interval x. Optional keyword arguments give the tolerances reltol and abstol. reltol is the tolerance on the relative error whereas abstol is the tolerance on |f(X)|, and a debug boolean argument that prints out diagnostic information.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.newton1d-Union{Tuple{T}, Tuple{Function,Interval{T}}} where T","page":"API","title":"IntervalRootFinding.newton1d","text":"newton1d performs the interval Newton method on the given function f and initial interval x. Optional keyword arguments give the tolerances reltol and abstol. reltol is the tolerance on the relative error whereas abstol is the tolerance on |f(X)|, and a debug boolean argument that prints out diagnostic information.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.quadratic_roots-Union{Tuple{T}, Tuple{Interval{T},Interval{T},Interval{T}}} where T","page":"API","title":"IntervalRootFinding.quadratic_roots","text":"Function to solve a quadratic equation where the coefficients are intervals. Returns an array of intervals of the roots. Arguments a, b and c are interval coefficients of x¬≤, x and 1 respectively. The interval case differs from the non-interval case in that there might be three disjoint interval roots. In the third case, one interval root extends to ‚àí‚àû and another extends to +‚àû. This algorithm finds the set of points where F.lo(x) ‚â• 0 and the set of points where F.hi(x) ‚â§ 0 and takes the intersection of these two sets. Eldon Hansen and G. William Walster : Global Optimization Using Interval Analysis - Chapter 8\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.Compl","page":"API","title":"IntervalRootFinding.Compl","text":"Complex numbers as 2-vectors, enough for polynomials.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.realify-Tuple{Any}","page":"API","title":"IntervalRootFinding.realify","text":"Takes a complex (polynomial) function f and returns a function g:R^2 -> R^2 that implements it.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.realify_derivative-Tuple{Any}","page":"API","title":"IntervalRootFinding.realify_derivative","text":"Takes the derivative of a complex function and returns the real jacobian that implements it.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.gauss_elimination_interval1!-Tuple{AbstractArray,AbstractArray{T,2} where T,AbstractArray}","page":"API","title":"IntervalRootFinding.gauss_elimination_interval1!","text":"Using Base.`\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.preconditioner-Tuple{AbstractArray{T,2} where T,AbstractArray}","page":"API","title":"IntervalRootFinding.preconditioner","text":"Preconditions the matrix A and b with the inverse of mid(A)\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.quadratic_helper!-Union{Tuple{T}, Tuple{Interval{T},Interval{T},Interval{T},Array{Interval{T},N} where N}} where T","page":"API","title":"IntervalRootFinding.quadratic_helper!","text":"Helper function for quadratic_interval that computes roots of a real quadratic using interval arithmetic to bound rounding errors.\n\n\n\n\n\n","category":"method"},{"location":"#IntervalRootFinding.jl-1","page":"Home","title":"IntervalRootFinding.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package provides guaranteed methods for finding roots of functions f mathbbR^n to mathbbR^n with n ge 1, i.e. vectors (or scalars, for n=1) mathbbx for which f(mathbbx) = mathbb0. In principle, it guarantees to find all roots inside a given box in mathbbR^n, or report subboxes for which it is unable to provide guarantees.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To do so, it uses methods from interval analysis, using interval arithmetic from the IntervalArithmetic.jl package by the same authors.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"warning: Warning\nWhile this package aimed at providing guaranteed results and despite our best efforts and test suite, some bugs may remain and there are several known issues with corner cases. Please look at the issue tracker and report there any odd and/or incorrect behavior.","category":"page"},{"location":"#Basic-1D-example-1","page":"Home","title":"Basic 1D example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To begin, we need a standard Julia function and an interval in which to search roots of that function. Intervals use the Interval type provided by the IntervalArithmetic.jl package and are generally constructed using the .. syntax, a..b representing the closed interval a b.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"When provided with this information, the roots function will return a vector of all roots of the function in the given interval.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using IntervalArithmetic, IntervalRootFinding\n\njulia> rts = roots(x -> x^2 - 2x, 0..10)\n2-element Array{Root{Interval{Float64}},1}:\n Root([1.99999, 2.00001], :unique)\n Root([0, 4.4724e-16], :unknown)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The roots are returned as Root objects, containing an interval and the status of that interval, represented as a Symbol. There are two possible types of root status, as shown in the example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":":unique: the given interval contains exactly one root of the function,\n:unknown: the given interval may or may not contain one or more roots; the algorithm used was unable to come to a conclusion.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The second status is still informative, since all regions of the original search interval not contained in any of the returned root intervals is guaranteed not to contain any root of the function. In the above example, we know that the function has no root in the interval 21 10, for example.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There are several known situations where the uniqueness (and existence) of a solution cannot be determined by the interval algorithms used in the package:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If the solution is on the boundary of the interval (as in the previous example);\nIf the derivative of the solution is zero at the solution.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In particular, the second condition means that multiple roots cannot be proven to be unique. For example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> g(x) = (x^2 - 2)^2 * (x^2 - 3)\ng (generic function with 1 method)\n\njulia> roots(g, -10..10)\n4-element Array{IntervalRootFinding.Root{IntervalArithmetic.Interval{Float64}},1}:\n Root([1.73205, 1.73206], :unique)\n Root([1.41418, 1.4148], :unknown)\n Root([-1.4148, -1.41418], :unknown)\n Root([-1.73206, -1.73205], :unique)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here we see that the two double roots are reported as being possible roots without guarantee and the simple roots have been proved to be unique.","category":"page"},{"location":"#Basic-multi-dimensional-example-1","page":"Home","title":"Basic multi-dimensional example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"For dimensions n  1, the function passed to roots must currently return an SVector from the StaticArrays.jl package.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here we give a 3D example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> function g( (x1, x2, x3) )\n           return SVector(x1^2 + x2^2 + x3^2 - 1,\n                          x1^2 + x3^2 - 0.25,\n                          x1^2 + x2^2 - 4x3\n                         )\n       end\ng (generic function with 1 method)\n\njulia> X = -5..5\n[-5, 5]\n\njulia> rts = roots(g, X √ó X √ó X)\n4-element Array{Root{IntervalBox{3,Float64}},1}:\n Root([0.440762, 0.440763] √ó [0.866025, 0.866026] √ó [0.236067, 0.236068], :unique)\n Root([0.440762, 0.440763] √ó [-0.866026, -0.866025] √ó [0.236067, 0.236068], :unique)\n Root([-0.440763, -0.440762] √ó [0.866025, 0.866026] √ó [0.236067, 0.236068], :unique)\n Root([-0.440763, -0.440762] √ó [-0.866026, -0.866025] √ó [0.236067, 0.236068], :unique)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Thus the system admits four unique roots in the box -5 5^3. We have used the unicode character √ó (typed as \\times<tab>) to compose several intervals into a multidimensional box.","category":"page"},{"location":"#Stationary-points-1","page":"Home","title":"Stationary points","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Stationary points of a function fmathbbR^n to mathbbR may be found as zeros of the gradient of f. The package exports the ‚àá operator to calculate gradients using ForwardDiff.jl:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> f( (x, y) ) = sin(x) * sin(y)\nf (generic function with 1 method)\n\njulia> ‚àáf = ‚àá(f)  # gradient operator from the package\n(::#53) (generic function with 1 method)\n\njulia> rts = roots(‚àáf, IntervalBox(-5..6, 2), Newton, 1e-5)\n25-element Array{IntervalRootFinding.Root{IntervalArithmetic.IntervalBox{2,Float64}},1}:\n Root([4.71238, 4.71239] √ó [4.71238, 4.71239], :unique)\n Root([4.71238, 4.71239] √ó [1.57079, 1.5708], :unique)\n ‚ãÆ\n [output snipped for brevity]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Now let's find the midpoints and plot them:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"midpoints = mid.(interval.(rts))\n\nxs = first.(midpoints)\nys = last.(midpoints)\n\nusing Plots; plotlyjs()\n\nsurface(-5:0.1:6, -6:0.1:6, (x,y) -> f([x, y]))\nscatter!(xs, ys, f.(midpoints))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The result is the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: stationary points)","category":"page"},{"location":"biblio/#Bibliography-1","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"biblio/#","page":"Bibliography","title":"Bibliography","text":"Applied Interval Analysis, L. Jaulin, M. Kieffer, O. Didrit & E. Walter. Springer (2001)\nGlobal Optimization Using Interval Analysis: Revised And Expanded, E. Hansen & G.W. Walster. CRC Press (2003)\nIntroduction to Interval Analysis, R.E. Moore, R.B. Kearfott & M.J. Cloud. SIAM (2009)\nValidated Numerics: A Short Introduction to Rigorous Computations, W. Tucker. Princeton University Press (2010)","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"This section describes some of the internal mechanism of the package and several ways to use them to customize a search.","category":"page"},{"location":"internals/#Branch-and-bound-1","page":"Internals","title":"Branch and bound","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"When roots is called, it performs a branch-and-bound search, that is, it iteratively looks at a region X and for each region tries to determine if it contains a root. It then does the following:","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"If X is proven to contain no root, it discards it.\nIf X is proven to contain exactly one root, it tries to get the best possible bounds for the root and store the resulting region in the list of Roots to output with a :unique status.\nIf the test is inconclusive and the size of X is smaller than the tolerance, it stores it in the list of Roots to output with :unknown status.\nIf the test is inconclusive and the size of X is larger than the tolerance, it bisects X and then processes each resulting half.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"At some point all regions will either have a determined status or be smaller than the tolerance, and the algorithm will halt and return all stored roots.","category":"page"},{"location":"internals/#Tree-representation-1","page":"Internals","title":"Tree representation","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"A branch-and-bound search can be naturally represented as a binary tree: each leaf contains a region and its status and each node represents a bisection. If the tree is known, the topology of the whole search can be reconstructed. There is however a point not determined by the tree.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The branch and bound algorithm used by the roots function builds this tree and at the end collect all leaves containing a region with status either :unknown or :unique. We see below how to access the tree.","category":"page"},{"location":"internals/#Search-strategy-1","page":"Internals","title":"Search strategy","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"While the tree representation is sufficient to know the topology of the search, it does not determine the order in which leaves are processed during the search. This has an influence on how the tree is created and the amount of memory used, but will not change the resulting tree, unless some limitations on the number of iterations or leaves are enforced.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"note: Note\nNo such limitations are currently implemented, but they are planned. They will allow to deal, for example, with functions admitting an infinite amount of roots.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Two strategies are currently available: a breadth-first strategy (leaves closer to the root of the tree are processed first); and a depth-first strategy (leaves further away from the root are processed first).","category":"page"},{"location":"internals/#Contractors-1","page":"Internals","title":"Contractors","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"To determine the status of a region, the algorithm uses so-called contractors. A Contractor is a callable object built from a function (in the case of Bisection) and possibly its derivative as well (for Newton and Krawczyk). When called with a region (wrapped in a Root object) and a tolerance, it returns the status of the root and the region (refined if the region contained a unique root).","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"julia> C = Newton(sin, cos)\nNewton{typeof(sin),typeof(cos)}(sin, cos)\n\njulia> C(Root(pi ¬± 0.001, :unknown), 1e-10)\nRoot([3.14159, 3.1416], :unique)\n\njulia> C(Root(2 ¬± 0.001, :unkown), 1e-10)\nRoot([1.99899, 2.00101], :empty)","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Contractors play a central role in the algorithm: they are the only part of it that varies for different methods.","category":"page"},{"location":"internals/#Search-object-1","page":"Internals","title":"Search object","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Now that we have presented the foundation of the internal algorithm, we can discuss the representation of the search. Each search strategy has a type associated, the defined types being BreadthFirstSearch and DepthFirstSearch.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"A search must be given three pieces of information:","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The region to search;\nA contractor;\nA tolerance.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"julia> f(x) = exp(x) - sin(x)\nf (generic function with 1 method)\n\njulia> df(x) = exp(x) - cos(x)\ndf (generic function with 1 method)\n\njulia> C = Newton(f, df)\nNewton{typeof(f),typeof(df)}(f, df)\n\njulia> search = DepthFirstSearch(-10..10, C, 1e-10)\nDepthFirstSearch{Interval{Float64},Newton{typeof(f),typeof(df)},\nFloat64}(Root([-10, 10], :unknown), Newton{typeof(f),typeof(df)}(f, df),\n1.0e-10)","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Then the search is performed using the iterator interface, i.e. a for loop.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"julia> current_tree = nothing   # stores current version of tree\n\njulia> for tree in search\n           global current_tree = tree\n       end\n\njulia> current_tree\nWorking tree with 9 elements of type Root{Interval{Float64}}\nIndices: [1, 2, 3, 4, 5, 7, 8, 9, 10]\nStructure:\n  [1] Node with children [2]\n    [2] Node with children [3, 4]\n      [3] Node with children [8, 9]\n        [8] Node with children [10]\n          [10] Leaf (:final) with data Root([-9.42486, -9.42485], :unique)\n        [9] Leaf (:final) with data Root([-6.28132, -6.28131], :unique)\n      [4] Node with children [5]\n        [5] Node with children [7]\n          [7] Leaf (:final) with data Root([-3.18307, -3.18306], :unique)","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The elements of the iteration are the trees (of type BBTree) that get constructed during the search. In the above example we simply get the final iteration of the tree and show it. The list of final roots can be retrieved using the data function:","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"julia> data(endtree)\n3-element Array{Root{Interval{Float64}},1}:\n Root([-3.18307, -3.18306], :unique)\n Root([-6.28132, -6.28131], :unique)\n Root([-9.42486, -9.42485], :unique)","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"We can use this interface to do some analysis at each iteration.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"julia> for (k, tree) in enumerate(search)\n           println(\"The tree at iteration $k has $(IntervalRootFinding.nnodes(tree)) nodes\")\n       end\nThe tree at iteration 1 has 3 nodes\nThe tree at iteration 2 has 5 nodes\nThe tree at iteration 3 has 4 nodes\n                ‚ãÆ   # several lines omitted for brevity\nThe tree at iteration 17 has 10 nodes\nThe tree at iteration 18 has 9 nodes\nThe tree at iteration 19 has 9 nodes","category":"page"}]
}

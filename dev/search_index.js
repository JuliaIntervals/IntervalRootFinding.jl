var documenterSearchIndex = {"docs":
[{"location":"roots/#roots-interface","page":"roots interface","title":"roots interface","text":"","category":"section"},{"location":"roots/#Methods","page":"roots interface","title":"Methods","text":"","category":"section"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"Three root-finding methods currently available through the roots interface are the following:","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"Newton (default);\nKrawczyk;\nBisection","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"Both the Newton and Krawczyk methods can determine if a root is unique in an interval, at the cost of requiring that the function is differentiable. The bisection method has no such requirement, but can never guarantee the existence or uniqueness of a root.","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"The method used is given as the third (optional) argument of the roots function:","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"julia> roots(log, -2..2, Newton)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999996, 1.00001], :unique)\n\njulia> roots(log, -2..2, Krawczyk)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999984, 1.00002], :unique)\n\njulia> roots(log, -2..2, Bisection)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999454, 1.00039], :unknown)","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"Note that as shown in the example, the log function does not complain about being given an interval going outside of its domain. While this may be surprising, this is the expected behavior and no root will ever be found outside the domain of a function.","category":"page"},{"location":"roots/#Explicit-derivatives","page":"roots interface","title":"Explicit derivatives","text":"","category":"section"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"Newton and Krawczyk methods require the function to be differentiable, but the derivative is usually computed automatically using forward-mode automatic differentiation, provided by the ForwardDiff.jl package. It is however possible to provide the derivative explicitly for these methods as the second argument of the roots function:","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"julia> roots(log, x -> 1/x, -2..2, Newton)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999996, 1.00001], :unique)\n\njulia> roots(log, x -> 1/x, -2..2, Krawczyk)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999984, 1.00002], :unique)","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"When providing the derivative explicitly, the computation is expected to be slightly faster, but the precision of the result is unlikely to be affected.","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"julia> using BenchmarkTools\n\njulia> @btime roots(log, x -> 1/x, -2..2, Newton)\n  38.600 μs (371 allocations: 27.01 KiB)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999996, 1.00001], :unique)\n\njulia> @btime roots(log, -2..2, Newton)\n  51.799 μs (373 allocations: 27.20 KiB)\n1-element Array{Root{Interval{Float64}},1}:\n Root([0.999996, 1.00001], :unique)","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"This may be useful in some special cases where ForwardDiff.jl is unable to compute the derivative of a function. Examples are complex functions and functions whose interval extension must be manually defined (e.g. special functions like zeta).","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"In dimension greater than one, the function of interest must return a SVector, a type provided by the StaticArrays package, but otherwise works in the same way as in the 1D case.","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"julia> function f( (x, y) )\n           return SVector(sin(x), cos(y))\n       end\nf (generic function with 1 method)\n\njulia> roots(f, IntervalBox(-3..3, 2))\n2-element Array{Root{IntervalBox{2,Float64}},1}:\n Root([-1.13556e-19, 2.3664e-20] × [1.57079, 1.5708], :unique)\n Root([-7.92188e-19, 3.20973e-19] × [-1.5708, -1.57079], :unique)","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"When providing the derivative for a multi-dimensional function, this must be given as a function returning the Jacobi matrix of the function as an SMatrix:","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"julia> function df( (x, y) )\n           return SMatrix{2, 2}(cos(x), 0, 0, -sin(y))\n       end\ndf (generic function with 1 method)\n\njulia> roots(f, df, IntervalBox(-3..3, 2), Newton)\n2-element Array{Root{IntervalBox{2,Float64}},1}:\n Root([-2.35877e-07, 8.22858e-07] × [1.57079, 1.5708], :unique)\n Root([-7.19393e-07, 1.55473e-06] × [-1.5708, -1.57079], :unique)","category":"page"},{"location":"roots/#Tolerance","page":"roots interface","title":"Tolerance","text":"","category":"section"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"An absolute tolerance for the search may be specified as the last argument of the roots function, the default being 1e-15. Currently a method must first be provided in order to be able to choose the tolerance.","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"julia> g(x) = sin(exp(x))\ng (generic function with 1 method)\n\njulia> roots(g, 0..2, Newton)\n2-element Array{Root{Interval{Float64}},1}:\n Root([1.83787, 1.83788], :unique)\n Root([1.14472, 1.14473], :unique)\n\njulia> roots(g, 0..2, Newton, 1e-2)\n2-element Array{Root{Interval{Float64}},1}:\n Root([1.83745, 1.83974], :unique)\n Root([1.14471, 1.14475], :unique)","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"A lower tolerance may greatly reduce the computation time, at the cost of an increased number of returned roots having :unknown status:","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"julia> h(x) = cos(x) * sin(1 / x)\nh (generic function with 1 method)\n\njulia> @btime roots(h, 0.05..1, Newton)\n  1.316 ms (9676 allocations: 202.21 KiB)\n6-element Array{Root{Interval{Float64}},1}:\n Root([0.106103, 0.106104], :unique)\n Root([0.318309, 0.31831], :unique)\n Root([0.0795774, 0.0795775], :unique)\n Root([0.0636619, 0.063662], :unique)\n Root([0.0530516, 0.0530517], :unique)\n Root([0.159154, 0.159155], :unique)             \n\njulia> @btime roots(h, 0.05..1, Newton, 1e-2)\n   475.500 μs (4171 allocations: 94.00 KiB)\n 6-element Array{Root{Interval{Float64}},1}:\n  Root([0.317179, 0.319299], :unique)\n  Root([0.157209, 0.165989], :unknown)\n  Root([0.104739, 0.107542], :unknown)\n  Root([0.0515382, 0.0531049], :unique)\n  Root([0.0785458, 0.0797755], :unknown)\n  Root([0.0570253, 0.0641614], :unknown)\n\njulia> @btime roots(h, 0.05..1, Newton, 1e-1)\n  151.101 μs (1382 allocations: 32.86 KiB)\n3-element Array{Root{Interval{Float64}},1}:\n Root([0.107541, 0.165989], :unknown)\n Root([0.283803, 0.3555], :unknown)\n Root([0.0499999, 0.107542], :unknown)     ","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"The last example shows a case where the tolerance was too large to be able to isolate the roots in distinct regions.","category":"page"},{"location":"roots/","page":"roots interface","title":"roots interface","text":"warning: Warning\nFor a root x of some function, if the absolute tolerance is smaller than eps(x) i.e. if tol + x == x, roots may never be able to converge to the required tolerance and the function may get stuck in an infinite loop.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Main-interface","page":"API","title":"Main interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [IntervalRootFinding]\nPages   = [\"roots.jl\"]","category":"page"},{"location":"api/#IntervalRootFinding.branch_and_prune-Tuple{Root, Any, Any, Any}","page":"API","title":"IntervalRootFinding.branch_and_prune","text":"branch_and_prune(X, contractor, search_order, tol)\n\nGeneric branch and prune routine for finding isolated roots using the given contractor to determine the status of a given box X.\n\nSee the documentation of the roots function for explanation of the other arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Polynomials.roots-Union{Tuple{S}, Tuple{C}, Tuple{Function, Any}, Tuple{Function, Any, Type{C}}, Tuple{Function, Any, Type{C}, Type{S}}, Tuple{Function, Any, Type{C}, Type{S}, Float64}} where {C<:IntervalRootFinding.AbstractContractor, S<:BranchAndPrune.SearchOrder}","page":"API","title":"Polynomials.roots","text":"roots(f, X, contractor=Newton, search_order=BreadthFirst, tol=1e-15)\nroots(f, deriv, X, contractor=Newton, search_order=BreadthFirst, tol=1e-15)\nroots(f, X, contractor, tol)\nroots(f, deriv, X, contractor, tol)\n\nUses a generic branch and prune routine to find in principle all isolated roots of a function f:R^n → R^n in a region X, if the number of roots is finite.\n\nInputs:\n\nf: function whose roots will be found\nX: Interval or IntervalBox in which roots are searched\ncontractor: function that, when applied to the function f, determines the status of a given box X. It returns the new box and a symbol indicating the status. Current possible values are Bisection, Newton and Krawczyk\nderiv: explicit derivative of f for Newton and Krawczyk\nsearch_order: SearchStrategy determining the order in which regions are processed.\ntol: Absolute tolerance. If a region has a diameter smaller than tol, it is returned with status :unknown.\n\n\n\n\n\n","category":"method"},{"location":"api/#Root-object","page":"API","title":"Root object","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [IntervalRootFinding]\nPages   = [\"root_object.jl\"]","category":"page"},{"location":"api/#IntervalRootFinding.Root","page":"API","title":"IntervalRootFinding.Root","text":"Root\n\nObject representing a possible root inside a given region. The field status is either :unknown or :unique. If status is :unique then we know that there is a unique root of the function in question inside the given region.\n\nInternally the status may also be :empty for region guaranteed to contain no root, however such Roots are discarded by default and thus never returned by the roots function.\n\nFields\n\ninterval: a region (either Interval of IntervalBox) searched for     roots.\nstatus: the status of the region, valid values are :empty, unknown and     :unique.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.isunique-Union{Tuple{Root{T}}, Tuple{T}} where T","page":"API","title":"IntervalRootFinding.isunique","text":"isunique(rt)\n\nReturn whether a Root is unique.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.root_region-Tuple{Root}","page":"API","title":"IntervalRootFinding.root_region","text":"root_region(rt)\n\nReturn the region associated to a Root.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.root_status-Tuple{Root}","page":"API","title":"IntervalRootFinding.root_status","text":"root_status(rt)\n\nReturn the status of a Root.\n\n\n\n\n\n","category":"method"},{"location":"api/#Contractors","page":"API","title":"Contractors","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [IntervalRootFinding]\nPages   = [\"contractors.jl\"]","category":"page"},{"location":"api/#IntervalRootFinding.AbstractContractor","page":"API","title":"IntervalRootFinding.AbstractContractor","text":"AbstractContractor{F}\n\nAbstract type for contractors.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.Bisection","page":"API","title":"IntervalRootFinding.Bisection","text":"Bisection{F} <: AbstractContractor{F}\n\nAbstractContractor type for the bisection method.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.Krawczyk","page":"API","title":"IntervalRootFinding.Krawczyk","text":"Krawczyk{F, FP} <: AbstractContractor{F}\n\nAbstractContractor type for the interval Krawczyk method.\n\nFields\n\n- `f::F`: function whose roots are searched\n- `f::FP`: derivative or jacobian of `f`\n\n\n\n(K::Krawczyk)(X ; α=where_bisect)\n\nContract an interval X using Krawczyk operator and return the contracted interval together with its status.\n\nInputs\n\n- `R`: Root object containing the interval to contract.\n- `α`: Point of bisection of intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.Newton","page":"API","title":"IntervalRootFinding.Newton","text":"Newton{F, FP} <: AbstractContractor{F}\n\nAbstractContractor type for the interval Newton method.\n\nFields\n\n- `f::F`: function whose roots are searched\n- `f::FP`: derivative or jacobian of `f`\n\n\n\n(N::Newton)(X, α=where_bisect)\n\nContract an interval X using Newton operator and return the contracted interval together with its status.\n\nInputs\n\n- `R`: Root object containing the interval to contract.\n- `α`: Point of bisection of intervals.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.contract-Tuple{Bisection, Root}","page":"API","title":"IntervalRootFinding.contract","text":"contract(contractor, R)\n\nContract the region R using the given contractor.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.refine-Tuple{IntervalRootFinding.AbstractContractor, Root, Any}","page":"API","title":"IntervalRootFinding.refine","text":"refine(op, X::Tuple{Symbol, Region}, tol)\n\nWrap the refine method to leave unchanged intervals that are not guaranteed to contain an unique solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.refine-Tuple{Union{Krawczyk, Newton}, Region, Any}","page":"API","title":"IntervalRootFinding.refine","text":"refine(C, X::Region, tol)\n\nRefine a interval known to contain a solution.\n\nThis function assumes that it is already known that X contains a unique root.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.safe_isempty-Tuple{Any}","page":"API","title":"IntervalRootFinding.safe_isempty","text":"safe_isempty(X)\n\nSimilar to isempty function for IntervalBox, but also works for SVector of Interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#Branch-and-bound-search-interface","page":"API","title":"Branch-and-bound search interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [IntervalRootFinding]\nPages   = [\"branch_and_bound.jl\"]","category":"page"},{"location":"api/#Others","page":"API","title":"Others","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [IntervalRootFinding]\nPages   = [\"complex.jl\", \"linear_eq.jl\", \"newton1d.jl\", \"quadratic.jl\", \"slopes.jl\"]","category":"page"},{"location":"api/#IntervalRootFinding.Compl","page":"API","title":"IntervalRootFinding.Compl","text":"Complex numbers as 2-vectors, enough for polynomials.\n\n\n\n\n\n","category":"type"},{"location":"api/#IntervalRootFinding.realify-Tuple{Any}","page":"API","title":"IntervalRootFinding.realify","text":"Takes a complex (polynomial) function f and returns a function g:R^2 -> R^2 that implements it.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.realify_derivative-Tuple{Any}","page":"API","title":"IntervalRootFinding.realify_derivative","text":"Takes the derivative of a complex function and returns the real jacobian that implements it.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.gauss_elimination_interval!-Tuple{AbstractArray, AbstractMatrix, AbstractArray}","page":"API","title":"IntervalRootFinding.gauss_elimination_interval!","text":"Solves the system of linear equations using Gaussian Elimination. Preconditioning is used when the precondition keyword argument is true.\n\nREF: Luc Jaulin et al., Applied Interval Analysis, pg. 72\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.gauss_elimination_interval1!-Tuple{AbstractArray, AbstractMatrix, AbstractArray}","page":"API","title":"IntervalRootFinding.gauss_elimination_interval1!","text":"Using Base.`\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.gauss_seidel_interval!-Tuple{AbstractArray, AbstractMatrix, AbstractArray}","page":"API","title":"IntervalRootFinding.gauss_seidel_interval!","text":"Iteratively solves the system of interval linear equations and returns the solution set. Uses the Gauss-Seidel method (Hansen-Sengupta version) to solve the system. Keyword precondition to turn preconditioning off. Eldon Hansen and G. William Walster : Global Optimization Using Interval Analysis - Chapter 5 - Page 115\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.preconditioner-Tuple{AbstractMatrix, AbstractArray}","page":"API","title":"IntervalRootFinding.preconditioner","text":"Preconditions the matrix A and b with the inverse of mid(A)\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.newton1d-Union{Tuple{T}, Tuple{Function, Function, Interval{T}}} where T","page":"API","title":"IntervalRootFinding.newton1d","text":"newton1d performs the interval Newton method on the given function f with its derivative f′ and initial interval x. Optional keyword arguments give the tolerances reltol and abstol. reltol is the tolerance on the relative error whereas abstol is the tolerance on |f(X)|, and a debug boolean argument that prints out diagnostic information.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.newton1d-Union{Tuple{T}, Tuple{Function, Interval{T}}} where T","page":"API","title":"IntervalRootFinding.newton1d","text":"newton1d performs the interval Newton method on the given function f and initial interval x. Optional keyword arguments give the tolerances reltol and abstol. reltol is the tolerance on the relative error whereas abstol is the tolerance on |f(X)|, and a debug boolean argument that prints out diagnostic information.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.quadratic_helper!-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}, Interval{T}, Array{Interval{T}}}} where T","page":"API","title":"IntervalRootFinding.quadratic_helper!","text":"Helper function for quadratic_interval that computes roots of a real quadratic using interval arithmetic to bound rounding errors.\n\n\n\n\n\n","category":"method"},{"location":"api/#IntervalRootFinding.quadratic_roots-Union{Tuple{T}, Tuple{Interval{T}, Interval{T}, Interval{T}}} where T","page":"API","title":"IntervalRootFinding.quadratic_roots","text":"Function to solve a quadratic equation where the coefficients are intervals. Returns an array of intervals of the roots. Arguments a, b and c are interval coefficients of x², x and 1 respectively. The interval case differs from the non-interval case in that there might be three disjoint interval roots. In the third case, one interval root extends to −∞ and another extends to +∞. This algorithm finds the set of points where F.lo(x) ≥ 0 and the set of points where F.hi(x) ≤ 0 and takes the intersection of these two sets. Eldon Hansen and G. William Walster : Global Optimization Using Interval Analysis - Chapter 8\n\n\n\n\n\n","category":"method"},{"location":"#IntervalRootFinding.jl","page":"Home","title":"IntervalRootFinding.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides guaranteed methods for finding roots of functions f mathbbR^n to mathbbR^n with n ge 1, i.e. vectors (or scalars, for n=1) mathbbx for which f(mathbbx) = mathbb0. In principle, it guarantees to find all roots inside a given box in mathbbR^n, or report subboxes for which it is unable to provide guarantees.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To do so, it uses methods from interval analysis, using interval arithmetic from the IntervalArithmetic.jl package by the same authors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nWhile this package aimed at providing guaranteed results and despite our best efforts and test suite, some bugs may remain and there are several known issues with corner cases. Please look at the issue tracker and report there any odd and/or incorrect behavior.","category":"page"},{"location":"#Basic-1D-example","page":"Home","title":"Basic 1D example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To begin, we need a standard Julia function and an interval in which to search roots of that function. Intervals use the Interval type provided by the IntervalArithmetic.jl package and are generally constructed using the .. syntax, a..b representing the closed interval a b.","category":"page"},{"location":"","page":"Home","title":"Home","text":"When provided with this information, the roots function will return a vector of all roots of the function in the given interval.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using IntervalArithmetic, IntervalRootFinding\n\njulia> rts = roots(x -> x^2 - 2x, 0..10)\n2-element Array{Root{Interval{Float64}},1}:\n Root([1.99999, 2.00001], :unique)\n Root([0, 4.4724e-16], :unknown)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The roots are returned as Root objects, containing an interval and the status of that interval, represented as a Symbol. There are two possible types of root status, as shown in the example:","category":"page"},{"location":"","page":"Home","title":"Home","text":":unique: the given interval contains exactly one root of the function,\n:unknown: the given interval may or may not contain one or more roots; the algorithm used was unable to come to a conclusion.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The second status is still informative, since all regions of the original search interval not contained in any of the returned root intervals is guaranteed not to contain any root of the function. In the above example, we know that the function has no root in the interval 21 10, for example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are several known situations where the uniqueness (and existence) of a solution cannot be determined by the interval algorithms used in the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"If the solution is on the boundary of the interval (as in the previous example);\nIf the derivative of the solution is zero at the solution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In particular, the second condition means that multiple roots cannot be proven to be unique. For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> g(x) = (x^2 - 2)^2 * (x^2 - 3)\ng (generic function with 1 method)\n\njulia> roots(g, -10..10)\n4-element Array{IntervalRootFinding.Root{IntervalArithmetic.Interval{Float64}},1}:\n Root([1.73205, 1.73206], :unique)\n Root([1.41418, 1.4148], :unknown)\n Root([-1.4148, -1.41418], :unknown)\n Root([-1.73206, -1.73205], :unique)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we see that the two double roots are reported as being possible roots without guarantee and the simple roots have been proved to be unique.","category":"page"},{"location":"#Basic-multi-dimensional-example","page":"Home","title":"Basic multi-dimensional example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For dimensions n  1, the function passed to roots must currently return an SVector from the StaticArrays.jl package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we give a 3D example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> function g( (x1, x2, x3) )\n           return SVector(x1^2 + x2^2 + x3^2 - 1,\n                          x1^2 + x3^2 - 0.25,\n                          x1^2 + x2^2 - 4x3\n                         )\n       end\ng (generic function with 1 method)\n\njulia> X = -5..5\n[-5, 5]\n\njulia> rts = roots(g, X × X × X)\n4-element Array{Root{IntervalBox{3,Float64}},1}:\n Root([0.440762, 0.440763] × [0.866025, 0.866026] × [0.236067, 0.236068], :unique)\n Root([0.440762, 0.440763] × [-0.866026, -0.866025] × [0.236067, 0.236068], :unique)\n Root([-0.440763, -0.440762] × [0.866025, 0.866026] × [0.236067, 0.236068], :unique)\n Root([-0.440763, -0.440762] × [-0.866026, -0.866025] × [0.236067, 0.236068], :unique)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Thus the system admits four unique roots in the box -5 5^3. We have used the unicode character × (typed as \\times<tab>) to compose several intervals into a multidimensional box.","category":"page"},{"location":"#Stationary-points","page":"Home","title":"Stationary points","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Stationary points of a function fmathbbR^n to mathbbR may be found as zeros of the gradient of f. The package exports the ∇ operator to calculate gradients using ForwardDiff.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> f( (x, y) ) = sin(x) * sin(y)\nf (generic function with 1 method)\n\njulia> ∇f = ∇(f)  # gradient operator from the package\n(::#53) (generic function with 1 method)\n\njulia> rts = roots(∇f, IntervalBox(-5..6, 2), Newton, 1e-5)\n25-element Array{IntervalRootFinding.Root{IntervalArithmetic.IntervalBox{2,Float64}},1}:\n Root([4.71238, 4.71239] × [4.71238, 4.71239], :unique)\n Root([4.71238, 4.71239] × [1.57079, 1.5708], :unique)\n ⋮\n [output snipped for brevity]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now let's find the midpoints and plot them:","category":"page"},{"location":"","page":"Home","title":"Home","text":"midpoints = mid.(interval.(rts))\n\nxs = first.(midpoints)\nys = last.(midpoints)\n\nusing Plots; plotlyjs()\n\nsurface(-5:0.1:6, -6:0.1:6, (x,y) -> f([x, y]))\nscatter!(xs, ys, f.(midpoints))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The result is the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: stationary points)","category":"page"},{"location":"biblio/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"biblio/","page":"Bibliography","title":"Bibliography","text":"Applied Interval Analysis, L. Jaulin, M. Kieffer, O. Didrit & E. Walter. Springer (2001)\nGlobal Optimization Using Interval Analysis: Revised And Expanded, E. Hansen & G.W. Walster. CRC Press (2003)\nIntroduction to Interval Analysis, R.E. Moore, R.B. Kearfott & M.J. Cloud. SIAM (2009)\nValidated Numerics: A Short Introduction to Rigorous Computations, W. Tucker. Princeton University Press (2010)","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This section describes some of the internal mechanism of the package and several ways to use them to customize a search.","category":"page"},{"location":"internals/#Branch-and-bound","page":"Internals","title":"Branch and bound","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"When roots is called, it performs a branch-and-bound search, that is, it iteratively looks at a region X and for each region tries to determine if it contains a root. It then does the following:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"If X is proven to contain no root, it discards it.\nIf X is proven to contain exactly one root, it tries to get the best possible bounds for the root and store the resulting region in the list of Roots to output with a :unique status.\nIf the test is inconclusive and the size of X is smaller than the tolerance, it stores it in the list of Roots to output with :unknown status.\nIf the test is inconclusive and the size of X is larger than the tolerance, it bisects X and then processes each resulting half.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"At some point all regions will either have a determined status or be smaller than the tolerance, and the algorithm will halt and return all stored roots.","category":"page"},{"location":"internals/#Tree-representation","page":"Internals","title":"Tree representation","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"A branch-and-bound search can be naturally represented as a binary tree: each leaf contains a region and its status and each node represents a bisection. If the tree is known, the topology of the whole search can be reconstructed. There is however a point not determined by the tree.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The branch and bound algorithm used by the roots function builds this tree and at the end collect all leaves containing a region with status either :unknown or :unique. We see below how to access the tree.","category":"page"},{"location":"internals/#Search-strategy","page":"Internals","title":"Search strategy","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"While the tree representation is sufficient to know the topology of the search, it does not determine the order in which leaves are processed during the search. This has an influence on how the tree is created and the amount of memory used, but will not change the resulting tree, unless some limitations on the number of iterations or leaves are enforced.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"note: Note\nNo such limitations are currently implemented, but they are planned. They will allow to deal, for example, with functions admitting an infinite amount of roots.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Two strategies are currently available: a breadth-first strategy (leaves closer to the root of the tree are processed first); and a depth-first strategy (leaves further away from the root are processed first).","category":"page"},{"location":"internals/#Contractors","page":"Internals","title":"Contractors","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"To determine the status of a region, the algorithm uses so-called contractors. A Contractor is a callable object built from a function (in the case of Bisection) and possibly its derivative as well (for Newton and Krawczyk). When called with a region (wrapped in a Root object) and a tolerance, it returns the status of the root and the region (refined if the region contained a unique root).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"julia> C = Newton(sin, cos)\nNewton{typeof(sin),typeof(cos)}(sin, cos)\n\njulia> C(Root(pi ± 0.001, :unknown), 1e-10)\nRoot([3.14159, 3.1416], :unique)\n\njulia> C(Root(2 ± 0.001, :unknown), 1e-10)\nRoot([1.99899, 2.00101], :empty)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Contractors play a central role in the algorithm: they are the only part of it that varies for different methods.","category":"page"},{"location":"internals/#Search-object","page":"Internals","title":"Search object","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Now that we have presented the foundation of the internal algorithm, we can discuss the representation of the search. Each search strategy has a type associated, the defined types being BreadthFirst and DepthFirst.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"A search must be given three pieces of information:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The region to search;\nA contractor;\nA tolerance.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"julia> f(x) = exp(x) - sin(x)\nf (generic function with 1 method)\n\njulia> df(x) = exp(x) - cos(x)\ndf (generic function with 1 method)\n\njulia> C = Newton(f, df)\nNewton{typeof(f),typeof(df)}(f, df)\n\njulia> search = DepthFirst(-10..10, C, 1e-10)\nDepthFirst{Interval{Float64},Newton{typeof(f),typeof(df)},\nFloat64}(Root([-10, 10], :unknown), Newton{typeof(f),typeof(df)}(f, df),\n1.0e-10)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Then the search is performed using the iterator interface, i.e. a for loop.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"julia> current_tree = nothing   # stores current version of tree\n\njulia> for tree in search\n           global current_tree = tree\n       end\n\njulia> current_tree\nWorking tree with 9 elements of type Root{Interval{Float64}}\nIndices: [1, 2, 3, 4, 5, 7, 8, 9, 10]\nStructure:\n  [1] Node with children [2]\n    [2] Node with children [3, 4]\n      [3] Node with children [8, 9]\n        [8] Node with children [10]\n          [10] Leaf (:final) with data Root([-9.42486, -9.42485], :unique)\n        [9] Leaf (:final) with data Root([-6.28132, -6.28131], :unique)\n      [4] Node with children [5]\n        [5] Node with children [7]\n          [7] Leaf (:final) with data Root([-3.18307, -3.18306], :unique)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The elements of the iteration are the trees (of type BBTree) that get constructed during the search. In the above example we simply get the final iteration of the tree and show it. The list of final roots can be retrieved using the data function:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"julia> data(endtree)\n3-element Array{Root{Interval{Float64}},1}:\n Root([-3.18307, -3.18306], :unique)\n Root([-6.28132, -6.28131], :unique)\n Root([-9.42486, -9.42485], :unique)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"We can use this interface to do some analysis at each iteration.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"julia> for (k, tree) in enumerate(search)\n           println(\"The tree at iteration $k has $(IntervalRootFinding.nnodes(tree)) nodes\")\n       end\nThe tree at iteration 1 has 3 nodes\nThe tree at iteration 2 has 5 nodes\nThe tree at iteration 3 has 4 nodes\n                ⋮   # several lines omitted for brevity\nThe tree at iteration 17 has 10 nodes\nThe tree at iteration 18 has 9 nodes\nThe tree at iteration 19 has 9 nodes","category":"page"}]
}
